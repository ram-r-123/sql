-- Drop tables in reverse dependency order
DROP TABLE JOURNEY;
DROP TABLE CARD_TAPS;
DROP TABLE STATION_LINES;
DROP TABLE LINE;
DROP TABLE BANK_CARD;
DROP TABLE OYSTER_CARD;
DROP TABLE PRINTED_TICKET;
DROP TABLE CUSTOMER;
DROP TABLE STATION;

-- Create LINE table
CREATE TABLE LINE (
    Line_id NUMBER,
    Line_name VARCHAR2(40 CHAR) NOT NULL UNIQUE,
    CONSTRAINT line_pk PRIMARY KEY (Line_id)
);

-- Create STATION table
CREATE TABLE STATION (
    Station_id NUMBER,
    Station_name VARCHAR2(40 CHAR) NOT NULL,
    Pink_reader_interchange VARCHAR2(40 CHAR) DEFAULT NULL,
    Zone_number NUMBER NOT NULL,
    CONSTRAINT station_pk PRIMARY KEY (Station_id)
);

-- Create STATION_LINES junction table
CREATE TABLE STATION_LINES (
    Station_id NUMBER,
    Line_id NUMBER,
    CONSTRAINT station_lines_pk PRIMARY KEY (Station_id, Line_id),
    CONSTRAINT station_lines_station_fk FOREIGN KEY (Station_id) REFERENCES STATION (Station_id) ON DELETE CASCADE,
    CONSTRAINT station_lines_line_fk FOREIGN KEY (Line_id) REFERENCES LINE (Line_id) ON DELETE CASCADE
);

-- Create CUSTOMER table
CREATE TABLE CUSTOMER (
    Customer_card_id NUMBER PRIMARY KEY,
    Card_type VARCHAR2(20) CHECK (Card_type IN ('BANK', 'OYSTER', 'PRINTED')),
    Payment_method_validity VARCHAR2(40) NOT NULL
);

-- Create BANK_CARD table
CREATE TABLE BANK_CARD (
    Bank_card_id NUMBER PRIMARY KEY,
    Expiry_date DATE NOT NULL,
    Sufficient_funds_available CHAR(1) CHECK (Sufficient_funds_available IN ('Y', 'N'))
);

-- Create OYSTER_CARD table
CREATE TABLE OYSTER_CARD (
    Oyster_id NUMBER PRIMARY KEY,
    Expiry_date DATE NOT NULL,
    Credit_limit_not_exceeded CHAR(1) CHECK (Credit_limit_not_exceeded IN ('Y', 'N'))
);

-- Create PRINTED_TICKET table
CREATE TABLE PRINTED_TICKET (
    Ticket_id NUMBER PRIMARY KEY,
    Expiry_date DATE NOT NULL,
    Ticket_valid_for_stations_travelled CHAR(1) CHECK (Ticket_valid_for_stations_travelled IN ('Y', 'N'))
);

-- Create CARD_TAPS table
CREATE TABLE CARD_TAPS (
    Tap_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    Customer_card_id NUMBER NOT NULL,
    Tap_datetime DATE DEFAULT SYSDATE NOT NULL,
    Station_id NUMBER NOT NULL,
    Tap_type VARCHAR2(10) CHECK (Tap_type IN ('IN', 'OUT', 'PINK')) NOT NULL,
    CONSTRAINT card_taps_customer_fk FOREIGN KEY (Customer_card_id) REFERENCES CUSTOMER (Customer_card_id),
    CONSTRAINT card_taps_station_fk FOREIGN KEY (Station_id) REFERENCES STATION (Station_id)
);

-- Create JOURNEY table
CREATE TABLE JOURNEY (
    Journey_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    Customer_card_id NUMBER NOT NULL,
    Check_in_tap NUMBER,
    Check_out_tap NUMBER,
    Journey_status VARCHAR2(20) CHECK (Journey_status IN ('IN_PROGRESS', 'COMPLETED', 'INCOMPLETE', 'INVALID_PAYMENT')) NOT NULL,
    CONSTRAINT journey_customer_fk FOREIGN KEY (Customer_card_id) REFERENCES CUSTOMER (Customer_card_id),
    CONSTRAINT journey_check_in_fk FOREIGN KEY (Check_in_tap) REFERENCES CARD_TAPS (Tap_id),
    CONSTRAINT journey_check_out_fk FOREIGN KEY (Check_out_tap) REFERENCES CARD_TAPS (Tap_id)
);

-- Insert LINE data
INSERT INTO LINE (Line_id, Line_name) VALUES
    (1, 'Bakerloo'),
    (2, 'Central'),
    (3, 'Circle'),
    (4, 'District'),
    (5, 'Hammersmith and City'),
    (6, 'Jubilee'),
    (7, 'Metropolitan'),
    (8, 'Northern'),
    (9, 'Piccadilly'),
    (10, 'Victoria'),
    (11, 'Waterloo and City');

-- Insert STATION data
INSERT INTO STATION (Station_id, Station_name, Pink_reader_interchange, Zone_number) VALUES
    (1, 'Bank', NULL, 1),
    (2, 'King''s Cross St Pancras', NULL, 1),
    (3, 'Baker Street', NULL, 1),
    (4, 'Moorgate', NULL, 1),
    (5, 'Liverpool Street', NULL, 1),
    (6, 'Paddington', NULL, 1),
    (7, 'Morden', NULL, 4),
    (8, 'Wimbledon', 'Y', 3);

-- Insert STATION_LINES data
INSERT INTO STATION_LINES (Station_id, Line_id) VALUES
    (1, 2),
    (1, 8),
    (1, 11),
    (2, 3),
    (2, 5),
    (2, 7),
    (2, 8),
    (2, 9),
    (2, 10),
    (3, 1),
    (3, 3),
    (3, 5),
    (3, 6),
    (3, 7),
    (4, 3),
    (4, 5),
    (4, 7),
    (4, 8),
    (5, 2),
    (5, 3),
    (5, 5),
    (5, 7),
    (6, 1),
    (6, 3),
    (6, 4),
    (6, 5),
    (7, 8),
    (8, 4);

-- Trigger: Insert BANK_CARD -> CUSTOMER (calculates validity from expiry and funds)
CREATE OR REPLACE TRIGGER trg_bank_card_to_customer
AFTER INSERT ON BANK_CARD
FOR EACH ROW
DECLARE
    v_validity CHAR(1);
BEGIN
    IF :NEW.Expiry_date >= TRUNC(SYSDATE) AND :NEW.Sufficient_funds_available = 'Y' THEN
        v_validity := 'Y';
    ELSE
        v_validity := 'N';
    END IF;

    INSERT INTO CUSTOMER (Customer_card_id, Card_type, Payment_method_validity)
    VALUES (:NEW.Bank_card_id, 'BANK', v_validity);
END;
/

-- Trigger: Insert OYSTER_CARD -> CUSTOMER (calculates validity from expiry and credit)
CREATE OR REPLACE TRIGGER trg_oyster_card_to_customer
AFTER INSERT ON OYSTER_CARD
FOR EACH ROW
DECLARE
    v_validity CHAR(1);
BEGIN
    IF :NEW.Expiry_date >= TRUNC(SYSDATE) AND :NEW.Credit_limit_not_exceeded = 'Y' THEN
        v_validity := 'Y';
    ELSE
        v_validity := 'N';
    END IF;

    INSERT INTO CUSTOMER (Customer_card_id, Card_type, Payment_method_validity)
    VALUES (:NEW.Oyster_id, 'OYSTER', v_validity);
END;
/

-- Trigger: Insert PRINTED_TICKET -> CUSTOMER (calculates validity from expiry and station validity)
CREATE OR REPLACE TRIGGER trg_ticket_to_customer
AFTER INSERT ON PRINTED_TICKET
FOR EACH ROW
DECLARE
    v_validity CHAR(1);
BEGIN
    IF :NEW.Expiry_date >= TRUNC(SYSDATE) AND :NEW.Ticket_valid_for_stations_travelled = 'Y' THEN
        v_validity := 'Y';
    ELSE
        v_validity := 'N';
    END IF;

    INSERT INTO CUSTOMER (Customer_card_id, Card_type, Payment_method_validity)
    VALUES (:NEW.Ticket_id, 'PRINTED', v_validity);
END;
/

-- Trigger: Sync BANK_CARD -> CUSTOMER (recalculates validity on update)
CREATE OR REPLACE TRIGGER trg_bank_card_sync
AFTER UPDATE OF Expiry_date, Sufficient_funds_available ON BANK_CARD
FOR EACH ROW
DECLARE
    v_validity CHAR(1);
BEGIN
    IF :NEW.Expiry_date >= TRUNC(SYSDATE) AND :NEW.Sufficient_funds_available = 'Y' THEN
        v_validity := 'Y';
    ELSE
        v_validity := 'N';
    END IF;

    UPDATE CUSTOMER
    SET Payment_method_validity = v_validity
    WHERE Customer_card_id = :NEW.Bank_card_id;
END;
/

-- Trigger: Sync OYSTER_CARD -> CUSTOMER (recalculates validity on update)
CREATE OR REPLACE TRIGGER trg_oyster_card_sync
AFTER UPDATE OF Expiry_date, Credit_limit_not_exceeded ON OYSTER_CARD
FOR EACH ROW
DECLARE
    v_validity CHAR(1);
BEGIN
    IF :NEW.Expiry_date >= TRUNC(SYSDATE) AND :NEW.Credit_limit_not_exceeded = 'Y' THEN
        v_validity := 'Y';
    ELSE
        v_validity := 'N';
    END IF;

    UPDATE CUSTOMER
    SET Payment_method_validity = v_validity
    WHERE Customer_card_id = :NEW.Oyster_id;
END;
/

-- Trigger: Sync PRINTED_TICKET -> CUSTOMER (recalculates validity on update)
CREATE OR REPLACE TRIGGER trg_ticket_sync
AFTER UPDATE OF Expiry_date, Ticket_valid_for_stations_travelled ON PRINTED_TICKET
FOR EACH ROW
DECLARE
    v_validity CHAR(1);
BEGIN
    IF :NEW.Expiry_date >= TRUNC(SYSDATE) AND :NEW.Ticket_valid_for_stations_travelled = 'Y' THEN
        v_validity := 'Y';
    ELSE
        v_validity := 'N';
    END IF;

    UPDATE CUSTOMER
    SET Payment_method_validity = v_validity
    WHERE Customer_card_id = :NEW.Ticket_id;
END;
/

-- Trigger: Create journey on TAP IN (and mark any previous IN_PROGRESS as INCOMPLETE)
CREATE OR REPLACE TRIGGER trg_tap_in_create_journey
AFTER INSERT ON CARD_TAPS
FOR EACH ROW
WHEN (NEW.Tap_type = 'IN')
DECLARE
    v_payment_valid CHAR(1);
    v_status VARCHAR2(20);
BEGIN
    -- Mark any existing IN_PROGRESS journeys as INCOMPLETE
    UPDATE JOURNEY
    SET Journey_status = 'INCOMPLETE'
    WHERE Customer_card_id = :NEW.Customer_card_id
      AND Journey_status = 'IN_PROGRESS';

    -- Check payment validity
    SELECT Payment_method_validity INTO v_payment_valid
    FROM CUSTOMER
    WHERE Customer_card_id = :NEW.Customer_card_id;

    IF v_payment_valid = 'Y' THEN
        v_status := 'IN_PROGRESS';
    ELSE
        v_status := 'INVALID_PAYMENT';
    END IF;

    -- Create new journey
    INSERT INTO JOURNEY (Customer_card_id, Check_in_tap, Journey_status)
    VALUES (:NEW.Customer_card_id, :NEW.Tap_id, v_status);
END;
/

-- Trigger: Complete journey on TAP OUT
CREATE OR REPLACE TRIGGER trg_tap_out_close_journey
AFTER INSERT ON CARD_TAPS
FOR EACH ROW
WHEN (NEW.Tap_type = 'OUT')
DECLARE
    v_journey_id NUMBER;
    v_current_status VARCHAR2(20);
    v_payment_valid CHAR(1);
    v_status VARCHAR2(20);
BEGIN
    -- Find the most recent journey without a check-out tap (IN_PROGRESS or INVALID_PAYMENT)
    SELECT Journey_id, Journey_status
    INTO v_journey_id, v_current_status
    FROM JOURNEY
    WHERE Customer_card_id = :NEW.Customer_card_id
      AND Journey_status IN ('IN_PROGRESS', 'INVALID_PAYMENT')
      AND Check_out_tap IS NULL
    ORDER BY Check_in_tap DESC
    FETCH FIRST ROW ONLY;

    -- Complete or keep invalid status based on current status
    IF v_current_status = 'IN_PROGRESS' THEN
        v_status := 'COMPLETED';
    ELSE
        v_status := 'INVALID_PAYMENT';
    END IF;

    UPDATE JOURNEY
    SET Check_out_tap = :NEW.Tap_id,
        Journey_status = v_status
    WHERE Journey_id = v_journey_id;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        -- No journey found, check payment validity
        SELECT Payment_method_validity INTO v_payment_valid
        FROM CUSTOMER
        WHERE Customer_card_id = :NEW.Customer_card_id;

        IF v_payment_valid = 'Y' THEN
            v_status := 'INCOMPLETE';
        ELSE
            v_status := 'INVALID_PAYMENT';
        END IF;

        INSERT INTO JOURNEY (Customer_card_id, Check_in_tap, Check_out_tap, Journey_status)
        VALUES (:NEW.Customer_card_id, NULL, :NEW.Tap_id, v_status);
END;
/

-- Insert test BANK_CARD data (triggers will create CUSTOMER records with calculated validity)
INSERT INTO BANK_CARD (Bank_card_id, Expiry_date, Sufficient_funds_available) VALUES
    (1001, TO_DATE('01/01/2027', 'DD/MM/YYYY'), 'Y'),
    (1002, TO_DATE('01/01/2027', 'DD/MM/YYYY'), 'Y'),
    (1003, TO_DATE('01/01/2027', 'DD/MM/YYYY'), 'Y'),
    (1004, TO_DATE('01/01/2027', 'DD/MM/YYYY'), 'Y'),
    (1005, TO_DATE('01/01/2027', 'DD/MM/YYYY'), 'Y');

-- Insert test OYSTER_CARD data
INSERT INTO OYSTER_CARD (Oyster_id, Expiry_date, Credit_limit_not_exceeded)
VALUES (2001, TO_DATE('01/01/2027', 'DD/MM/YYYY'), 'N');

-- Insert test PRINTED_TICKET data
INSERT INTO PRINTED_TICKET (Ticket_id, Expiry_date, Ticket_valid_for_stations_travelled)
VALUES (3001, TO_DATE('06/11/2025', 'DD/MM/YYYY'), 'Y');

-- Insert test CARD_TAPS data (triggers will create/update JOURNEY records)
-- Note: Tap_id is auto-generated, Station_ids must exist in STATION table
INSERT INTO CARD_TAPS (Customer_card_id, Tap_datetime, Station_id, Tap_type)
VALUES (1001, TO_DATE('07/11/2025 10:00', 'DD/MM/YYYY HH24:MI'), 1, 'IN');

INSERT INTO CARD_TAPS (Customer_card_id, Tap_datetime, Station_id, Tap_type)
VALUES (1001, TO_DATE('07/11/2025 10:30', 'DD/MM/YYYY HH24:MI'), 2, 'OUT');

INSERT INTO CARD_TAPS (Customer_card_id, Tap_datetime, Station_id, Tap_type)
VALUES (1002, TO_DATE('08/11/2025 21:00', 'DD/MM/YYYY HH24:MI'), 3, 'IN');

INSERT INTO CARD_TAPS (Customer_card_id, Tap_datetime, Station_id, Tap_type)
VALUES (1002, TO_DATE('08/11/2025 22:07', 'DD/MM/YYYY HH24:MI'), 4, 'OUT');

INSERT INTO CARD_TAPS (Customer_card_id, Tap_datetime, Station_id, Tap_type)
VALUES (1003, TO_DATE('08/11/2025 22:15', 'DD/MM/YYYY HH24:MI'), 5, 'OUT');

INSERT INTO CARD_TAPS (Customer_card_id, Tap_datetime, Station_id, Tap_type)
VALUES (1004, TO_DATE('09/11/2025 08:00', 'DD/MM/YYYY HH24:MI'), 6, 'IN');

INSERT INTO CARD_TAPS (Customer_card_id, Tap_datetime, Station_id, Tap_type)
VALUES (1005, TO_DATE('09/11/2025 08:00', 'DD/MM/YYYY HH24:MI'), 7, 'IN');

COMMIT;
